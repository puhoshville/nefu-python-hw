# NEFU Python
## HomeWork 2. Data structures!


### Task 1
* Даны строки J и S.  Напишите функцию, возвращающую количество элементов (символов) строки S, которые встречаются 
в строке J. Символы "a" и "A" рассматриваются как отличные друг от друга.
    
    Пример 1:
    ```
    Input: J = "aA", S = "aAAbbbb"
    Output: 3
    ```
    Пример 2:
    ```
    Input: J = "z", S = "ZZ"
    Output: 0
    ```
    
    ```python
    def number_of_matches(J, S):
        pass
    ```

### Task 2
* Дан список целых чисел `A`. Напишите функцию, которая для массива `A` будет возвращать список квадратов чисел 
из `A`, отсортированный по порядку неубывания.

    ```
    Пример 1:
    Input: [-4,-1,0,3,10]
    Output: [0,1,9,16,100]
    
    Пример 2:
    Input: [-7,-3,2,3,11]
    Output: [4,9,9,49,121]
    ```
    
    ```python
    def get_sorted_squares(nums):
        pass
    ```
    
### Task 3
* Азбука Морзе - стандартный метод кодирования, где за каждой буквой закреплено некоторая последовательность 
"точек" и "тире". Например, "A" ~ ".-", "B" ~ "-...", "C" ~ "-.-."  и т.д. Ниже приведен список кодов 26-ти букв 
английского алфавита.

    ```python
    morse_base = [
        ".-","-...","-.-.","-..",".","..-.","--.","....","..",".---", 
        "-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-",
        "..-","...-",".--","-..-","-.--","--.."
    ]
    ``` 
    Вам дан список слов, слова можно закодировать исползуя Азубку Морзе. Напишите функцию, которая вернет количество 
    уникальных шифров, полученных после кодирования. 
    ```
    Пример:
    Input: words = ["gin", "zen", "gig", "msg"]
    Output: 2
    Подробнее: 
    "gin" -> "--...-."
    "zen" -> "--...-."
    "gig" -> "--...--."
    "msg" -> "--...--."
    
    Две унивкальные последовательности: "--...-." и "--...--.".
    ```
    Note:
    ```
    Максимальное количество слов: 100.
    Максимальная длина слова: [1, 12].
    Все слова на вход подаются в нижнем регистре.
    ```
    ```python
    def count_unique_codes(words):
        pass
    ```

### Task 4
Дан массив слов. Найти `k` самых часто встречаемых в нем. Реализуйте функцию, которая на вход будет получать список
слов и натуральное число `k`, а на выход вернет список `k` самых часто встречаемых отсортированный по частоте от 
большего к меньшему.

```
Пример:
Input: ["hello", "world", "hello", "my", "dear", "world", "hello"], k=3
Output: ["hello", "world", "dear"]
```
    
```python
def get_most_frequent(words, k):
    pass

```

### Task 5
Дана строка содержащая скобки `(` и `)`. Определить, является ли данная строка валидным выражением. Реализуйте функцию,
которая будет возвращать `True`, если выражение является валидным и `False` в ином случае.

Под валидными выражением будем понимать правильно открытые и закрытые скобки.
    
```
Пример:
"()" => True
"(" => False
"()()" => True
"(()(" => False
и т.д 
```
```python
def is_valid(braces_string):
    pass

```

### Task 6
* Даны список целых чисел `nums` и некоторое целое число `target`. Требуется найти два числа из списка `nums` такие,
что их сумма равно значению `target`. Реализуйте функцию, которая будет принимать на вход `nums` и `target`, а 
возвращает индексы чисел, удовлетворяющих условию задачи. Если таких чисел нет - функция должна вернуть None. Если 
таких пар несколько, вернуть любую из них.

```
Пример:
Input: nums  = [2, 7, 11, 15], target = 9,
Output: [0, 1] (т.к. nums[0] + nums[1] == 9)
```  
```python
def get_two_sum(nums, target):
    pass
```


### Task 7
* Решить задачу аналогичную предыдущей, только для случая трех чисел.

```
Пример:
Input: nums  = [2, 7, 11, 15], target = 24,
Output: [0, 1, 3] (т.к. nums[0] + nums[1] + nums[3] == 24)
```   
```python
def get_three_sum(nums, t):
    pass
```


### Task 8
* Дана строка символов нижнего регистра (a-z). Мы хотим разбить строку на максимальное количество непересекающихся 
частей таким образом, чтобы каждый символ содержался максимум в одной из частей. Напишите функцию, которая вернет 
список таких частей.

```
Пример 1:

Input: S = "qbqbcbqcqdufugduhxjhklxj"
Output: ["qbqbcbqcq", "dufugdu", "hxjhklxj"]

Разбиение "qbqbcbqcqdufugdu", "hxjhklxj" некорректно, т.к. можно разбить на три части.
```

```python
def get_partition(S):
    pass
```

